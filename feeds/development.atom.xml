<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Prag-o-matic - development</title><link href="http://www.duncan.dickinson.name/" rel="alternate"></link><link href="https://www.duncan.dickinson.name/feeds/development.atom.xml" rel="self"></link><id>http://www.duncan.dickinson.name/</id><updated>2015-01-15T16:20:00+10:00</updated><entry><title>Continuous Integration</title><link href="http://www.duncan.dickinson.name/2015/01/continuousintegration.html" rel="alternate"></link><published>2015-01-15T16:20:00+10:00</published><updated>2015-01-15T16:20:00+10:00</updated><author><name>Duncan</name></author><id>tag:www.duncan.dickinson.name,2015-01-15:/2015/01/continuousintegration.html</id><summary type="html">&lt;p&gt;&lt;em&gt;“It works on my machine” really translates to “I don’t know why it works - I just clicked buttons” and the offender forced to buy lunch for the team&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Continuous Integration (CI) focusses on ensuring that a project’s code successfully builds whenever the code base (usually stored in a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;“It works on my machine” really translates to “I don’t know why it works - I just clicked buttons” and the offender forced to buy lunch for the team&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Continuous Integration (CI) focusses on ensuring that a project’s code successfully builds whenever the code base (usually stored in a version control system) changes. The &amp;quot;continuous&amp;quot; aspect relates to the fact that the build is run every time code is checked in (committed). Given that some approaches see each team member commit code several times a day, the CI system may be quite busy. Having worked in a team where one member kept on committing code that broke the build, using a CI approach helped us determine where problems were coming from and saved time misspent thinking that your own code is wrong (&lt;tt class="docutils literal"&gt;svn blame&lt;/tt&gt; &lt;a class="footnote-reference" href="#f1" id="id1"&gt;[1]&lt;/a&gt;).&lt;/p&gt;
&lt;blockquote&gt;
In fact you could have a CI process that rolls back a commit that breaks the build.&lt;/blockquote&gt;
&lt;p&gt;The CI approach differs somewhat from approaches such as “nightly builds” as it really is continuous and can really help make sure people are only committing code that doesn’t break the build &lt;a class="footnote-reference" href="#f2" id="id2"&gt;[2]&lt;/a&gt;. This constant feedback loop should trigger a fix immediately whilst the code is “top of mind”. An associated work practice is “pull often, commit small, commit often” so that the team is working in-step and the CI process helps capture issues before they get too big &lt;a class="footnote-reference" href="#f3" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This may sound a little complex but a CI process really has only 3 responsibilities:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Trigger a build when new code is checked into version control &lt;a class="footnote-reference" href="#f4" id="id4"&gt;[4]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Run the build and its associated unit tests&lt;/li&gt;
&lt;li&gt;Report on any failures&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Your CI process doesn’t have to be a huge bells and whistles affair. In the most basic case it may be a desktop PC that developers walk over to and manually start a build. The use of a separate system for CI helps reduce (but not eliminate) the false positives that occur when a build succeeds on a developer’s machine because of the miscellaneous debris crawling around developer laptops (old versions, libraries on classpaths that aren’t included in the build config etc).&lt;/p&gt;
&lt;p&gt;There are many CI systems around that help you get going with a more automated CI environment:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I’ve used &lt;a class="reference external" href="http://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; and, prior to that, &lt;a class="reference external" href="http://hudson-ci.org/"&gt;Hudson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The team I’m with at present are working with &lt;a class="reference external" href="https://www.atlassian.com/software/bamboo"&gt;Atlassian Bamboo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.go.cd/"&gt;ThoughtWorks’ Go&lt;/a&gt; has been made available as open source&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://continuum.apache.org/"&gt;Apache Continuum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re after an online service, take a look at &lt;a class="reference external" href="https://travis-ci.org/recent"&gt;Travis&lt;/a&gt; - I’ve not used it but it gets good press.&lt;/p&gt;
&lt;div class="section" id="automating-your-build"&gt;
&lt;h2&gt;Automating your build&lt;/h2&gt;
&lt;p&gt;Automating your build is extremely useful in terms of successfully establishing your CI environment but, beyond this, it’s a good candidate for the “best practice” list. In a CI environment an (efficient) automated build is extremely important as the build should be possible without manual intervention. Long build times may indicate that the build needs to be broken up into smaller components or that your tests are verging away from unit tests towards integration testing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="workflows"&gt;
&lt;h2&gt;Workflows&lt;/h2&gt;
&lt;p&gt;In a coding approach where you use branching workflows you might have the CI system “watch” only certain branches. Furthermore, it could be useful to consider a &lt;a class="reference external" href="http://www.yegor256.com/2014/07/21/read-only-master-branch.html"&gt;Read Only Master Branch&lt;/a&gt; in which individuals/features/ideas/etc have their own branch but a merge to the master branch is tested &lt;em&gt;before&lt;/em&gt; being accepted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="component-based-development"&gt;
&lt;h2&gt;Component-based development&lt;/h2&gt;
&lt;p&gt;A CI server can be very useful in projects that have teams working on separate components. For example, Apache Maven-based projects can have their CI server deploy SNAPSHOT artefacts to an artefact server (such as &lt;a class="reference external" href="http://www.sonatype.com/nexus"&gt;Sonatype Nexus&lt;/a&gt;). This means that other developers with that dependency will have the new component version downloaded the next time they run a build.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="steak-knives"&gt;
&lt;h2&gt;Steak knives&lt;/h2&gt;
&lt;p&gt;As you develop your CI infrastructure you can start exploring a number of toolsets that can further aid the development effort:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Software metric tools such as &lt;a class="reference external" href="http://www.sonarqube.org/"&gt;SonarQube&lt;/a&gt; can help you hone in on areas of weakness in your code quality (e.g. duplication, dodgy coding practice or a lack of documentation)&lt;ul&gt;
&lt;li&gt;These are best run less frequently (nightly) as they can be time consuming&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Generate your documentation such as your javadoc or Maven site on a nightly basis&lt;/li&gt;
&lt;li&gt;Create a “clean room” build that freshly downloads all dependencies before building - this really helps catch issues such as 3rd-party libraries that just disappear.&lt;/li&gt;
&lt;li&gt;Deploy an instance of the built service into a virtual machine for user testing, interface testing (e.g. with &lt;a class="reference external" href="http://www.seleniumhq.org/"&gt;Selenium&lt;/a&gt; or integration tests &lt;a class="footnote-reference" href="#f5" id="id5"&gt;[5]&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Also best run less frequently - especially if you’re going to be soaking up a fair bit of system resources.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Get &lt;a class="reference external" href="https://wiki.jenkins-ci.org/display/JENKINS/ChuckNorris+Plugin"&gt;Chuck Norris&lt;/a&gt; in to make sure people know you’re serious!&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="test-drive"&gt;
&lt;h2&gt;Test drive&lt;/h2&gt;
&lt;p&gt;Most CI systems are quite easy to install and get running - even just on your laptop. I’d suggest that the best first-step is to allocate 3–4 hours to install a CI system (try Jenkins), configure a job for your main codebase, run it and see how it goes. Then, add in Chuck Norris.&lt;/p&gt;
&lt;p class="rubric"&gt;Footnotes&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="f1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;This was used as an in-joke - see the &lt;a class="reference external" href="http://svnbook.red-bean.com/en/1.7/svn.ref.svn.c.blame.html"&gt;SVN Book&lt;/a&gt; - but, seriously, the CI server is not a torture device that lets everyone insult a team member.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="f2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;In a regular environment I consider the build to be broken when it won’t compile or a unit test fails. Usually a less-frequent build would run other tests (integration, UI etc) but I usually label failures differently (e.g. “broke the deployment”)&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="f3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;It can be useful to manually trigger the more comprehensive build and test suite once a feature is complete - why wait until tomorrow to see if it’s broken?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="f4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Look at &lt;a class="reference external" href="https://help.github.com/articles/about-webhooks"&gt;GitHub&lt;/a&gt; and &lt;a class="reference external" href="https://confluence.atlassian.com/display/BITBUCKET/Manage+Bitbucket+hooks"&gt;BitBucket&lt;/a&gt; (Web)hooks for the push-model approach.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="f5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Most of my integration testing experience has been manual or script-based. However, projects such as &lt;a class="reference external" href="http://www.citrusframework.org/"&gt;Citrus Framework&lt;/a&gt; look to provide a good basis for easily established integration tests.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="development"></category><category term="maven"></category><category term="continuous integration"></category></entry><entry><title>Version control</title><link href="http://www.duncan.dickinson.name/2014/12/version-control.html" rel="alternate"></link><published>2014-12-26T07:00:00+10:00</published><updated>2014-12-26T07:00:00+10:00</updated><author><name>Duncan</name></author><id>tag:www.duncan.dickinson.name,2014-12-26:/2014/12/version-control.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Don’t write a single line of code until you have a version control system in place&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Almost all developers know of at least one version control system (also called source code control or revision control). These systems provide a backup of your work and allow you to dip back …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Don’t write a single line of code until you have a version control system in place&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Almost all developers know of at least one version control system (also called source code control or revision control). These systems provide a backup of your work and allow you to dip back into the past to find some lost code or work out where a bug may have crept in. However, with a head full of steam and the desire to get a prototype going to demo to the team/client/world you’ll fire up an IDE and start coding and version control won’t enter your head. Stop for just 5 minutes and get a version control repository running first. This is an insurance policy for a number of things:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;you have a backup when your laptop dies on you&lt;/li&gt;
&lt;li&gt;when you decide to tear down a section of code - you can always revert back if you find you’ve gone down the wrong path&lt;/li&gt;
&lt;li&gt;you can easily share your code and encourage others to assist&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="which-to-use"&gt;
&lt;h2&gt;Which to use?&lt;/h2&gt;
&lt;p&gt;There are several contemporary version control systems you could consider using, each with their own benefits. Client-server (or centralised) version control systems maintain a master copy on a central server with a local copy being “checked out” by a client. Generally the server maintains the full version history and the client only accesses a specific version as a working copy. Distributed version control systems (DVCS) don’t require a central master copy and all instances of the codebase includes the full version history.&lt;/p&gt;
&lt;p&gt;If you don’t currently use a version control system, the following options are worth exploring as they’re heavily used and well documented:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Git_(software)"&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Mercurial"&gt;Mercurial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Subversion"&gt;Subversion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re able to influence the selection of a version control system, it’d be worth opting for a DVCS such as Git - it has a lot of support and most up-to-date developers have used it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hosted-services"&gt;
&lt;h2&gt;Hosted services&lt;/h2&gt;
&lt;p&gt;Historically, developers may have deferred the use of a version control system as these needed to be installed and managed on a server. However, there are a number of hosted services that take away the burden of running your own version control system. Some offer free hosting, usually for open source projects, but also offer paid accounts for closed codebases.&lt;/p&gt;
&lt;p&gt;The key hosted version control providers include:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bitbucket.org/"&gt;Atlassian's Bitbucket&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.codeplex.com/"&gt;Microsoft's Codeplex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://code.google.com/"&gt;Google code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://sourceforge.net/"&gt;Sourceforge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="version-control-workflows"&gt;
&lt;h2&gt;Version control workflows&lt;/h2&gt;
&lt;p&gt;It's one thing to use version control, it's another to use it effectively - especially when you have larger teams or multiple product versions. &lt;a class="reference external" href="https://www.atlassian.com/git/tutorials/comparing-workflows"&gt;Atlassian provide an excellent overview&lt;/a&gt; of the most common Git workflows - it's well worth your reading time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="one-last-note"&gt;
&lt;h2&gt;One last note&lt;/h2&gt;
&lt;p&gt;DropBox and Google Drive are not version control systems for development purpose. They are great systems for sharing documents etc but there’s a lot more development functionality and integration options in a good version control system.&lt;/p&gt;
&lt;/div&gt;
</content><category term="development"></category><category term="project management"></category></entry></feed>